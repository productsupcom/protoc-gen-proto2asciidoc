package formatter

import (
	"bytes"
	"fmt"
	"path"
	"strings"
	"text/template"

	"github.com/productsupcom/protoc-gen-kit/kit"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	_ "embed"
)

type Asciidoc struct {
	Formatter
}

// it would be nicer to ship this with the template as a file for in-promptu updates
// however that would require the user side to figure out paths etc
//go:embed templates/message.tpl
var messageTpl string

//go:embed templates/enum.tpl
var enumTpl string

//go:embed templates/service.tpl
var serviceTpl string

func (ad *Asciidoc) GetFile(desc kit.Desc) *pluginpb.CodeGeneratorResponse_File {
	var out strings.Builder

	out.WriteString("// File generated by protoc-gen-proto2asciidoc. DO NOT EDIT.\n")
	out.WriteString("// source: ")
	out.WriteString(desc.Name)
	out.WriteString("\n\n")

	for _, service := range desc.Services {
		type Data struct {
			Service    kit.Service
			Parameters kit.Parameters
		}

		out.WriteString(Format(serviceTpl, Data{service, desc.Parameters}))
	}

	for _, msg := range desc.Messages {
		type Data struct {
			Message    kit.Message
			Parameters kit.Parameters
		}

		out.WriteString(Format(messageTpl, Data{msg, desc.Parameters}))
	}

	for _, enum := range desc.Enums {
		type Data struct {
			Enum       kit.Enum
			Parameters kit.Parameters
		}

		out.WriteString(Format(enumTpl, Data{enum, desc.Parameters}))
	}

	name := strings.Replace(desc.Name, path.Ext(desc.Name), ".gen.adoc", 1)
	content := out.String()

	return &pluginpb.CodeGeneratorResponse_File{
		Name:    &name,
		Content: &content,
	}
}

func BoolIcon(v interface{}, p kit.Parameters) string {
	val := false
	if in, ok := v.(*bool); ok {
		if in != nil {
			val = *in
		}
	}
	if param, ok := p["icons"]; ok && param == "on" {
		if val {
			return "{true-icon}"
		}
		return "{false-icon}"
	}
	if val {
		return "true"
	}
	return "false"
}

func GetTypeFromString(s *string, p kit.Parameters) string {
	if s == nil {
		return ""
	}

	fqtn := strings.Split(*s, ".")
	if val, ok := p["extension"]; ok && val == "on" {
		return fmt.Sprintf("proto2asciidoc:message[%s]", fqtn[len(fqtn)-1])
	}
	return fmt.Sprintf("<<%s_message>>", fqtn[len(fqtn)-1])
}

func GetFieldType(f kit.Field, p kit.Parameters) string {
	if f.TypeName != nil && f.Type != nil {
		fqtn := strings.Split(*f.TypeName, ".")
		if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
			if val, ok := p["extension"]; ok && val == "on" {
				return fmt.Sprintf("proto2asciidoc:message[%s]", fqtn[len(fqtn)-1])
			}
			return fmt.Sprintf("<<%s_message>>", fqtn[len(fqtn)-1])
		}
		if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
			if val, ok := p["extension"]; ok && val == "on" {
				return fmt.Sprintf("proto2asciidoc:enum[%s]", fqtn[len(fqtn)-1])
			}
			return fmt.Sprintf("<<%s_enum>>", fqtn[len(fqtn)-1])
		}
	}
	return strings.ToLower(strings.TrimLeft(f.Type.String(), "TYPE_"))
}

func Format(tpl string, data interface{}) string {
	buf := bytes.NewBuffer([]byte{})
	t, err := template.New("").
		Funcs(template.FuncMap{
			"GetFieldType":      GetFieldType,
			"BoolIcon":          BoolIcon,
			"GetComments":       kit.GetComments,
			"GetTypeFromString": GetTypeFromString,
		}).
		Parse(tpl)
	if err != nil {
		panic(err)
	}

	err = t.Execute(buf, data)
	if err != nil {
		panic(err)
	}

	return buf.String()
}

func CleanComment(s string) string {
	var out []string
	buf := strings.Split(s, "\n")
	for _, line := range buf {
		if len(line) == 0 {
			continue
		}
		if !strings.Contains(line, "tag::") && !strings.Contains(line, "end::") {
			out = append(out, line)
		}
	}

	return strings.Join(out, "\n")
}
